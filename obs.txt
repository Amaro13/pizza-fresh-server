Basic tips for typescript

npm init -y
npm i -D typescript
npx tsc --init
//The one below creates the index.js as written on the ts
npx tsc
//Insert in package.json
"start": "node dist/index.js",
    "build": "npx tsc",
    "build-and-run": "npm run build && npm start"

the last one builds and runs the index.js

// Create the dist folder and update the tsconfig.json. Don't forget to make it not a coment genius.
"outDir": "./dist"


// Installing the NestJS
npm i -g @nestjs/cli

// Starting a new project
nest new (nestjs-intr) -> name of the project

// Use of the usual npm run, in the package.json you can see the start options, while working use nest start:dev to watch for changes in files

//in the controller you controll the routes access just insert in the @controller or @get

//in the service you provide the data or functions into the project

// first thing to do is create the .editorconfig  and fill it like so:
# EditorConfig is awesome: https://EditorConfig.org

# top-most EditorConfig file
root = true

[*]
indent_style = space
indent_size = 2
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true // optional because frankly this one can get on your nerves while coding since it inserts the final newline everytime you stop using the keyboard and sometimes you don't need to.

// change the listen port in the main to another besides 3000 so it doesn't start a conflict with other ports since most use 3000 already

// when changing a function from a module, change using F2, using it this way changes it's name from all modules so there is no conflict.

// first thing to create is the back end data, start by creating the folder and the file in the src folder (in this case is the table)

// Pay very close attention to this table, and how it's created, notice the usability, the ease and the direction in witch the data flows, much better than before, use it read the coments and understand all of it, in doubt ask your brother or freaking google, for fucks sake study more, sacrifice a saturday more often you lazy bum.

// after the creation of the module, controller and service for the table, create another folder inside called dto(Data Transfer Object) witch is a simple object used to transfer data from one place into another

// Now it's time to create a folder inside the src called entities, an entity is a representation of a conjunction of informations about a determined concept of the system. All entities have atributes, witch are the informations that reference the entity.

// Now install the validator and transformer with npm i class-validator class-transformer. With them installed you can now validate data that will be passed through the databank. Change the main and dt as required for it

// Now install the swagger with: npm i @nestjs/swagger swagger-ui-express

// Set the swagger properly in the main, app  controller, table controller and in the dto. Observe that the swagger can now be checked in the localhost while the back is running.

// install postgres and beekeeper, they are the databank storage programs that will be used in this project, when you install the postgres you will have to create the username and password, inform them in beekeeper and connect

// An ORM maps between an Object Model and a Relational Database. An ODM maps between an Object Model and a Document Database.
// ODM on the other hand is an Object Document Mapper, which maps objects with a Document Database like MongoDB.
//The main difference is that ORM is for MySQL databases, while ODM does the mapping for document representation of data. Best way to remember what ORM does would be to think of it as an excel spread sheet, with rows and columns. When using this set up, you want to be sure you have a great plan on how you want to tackle the current application, it does not allow as many modifications like ODM does. With ODM we can add new fields and properties easily but with ORM when adding a new field you need to keep in mind that nothing stays empty so it needs a value to be as default unless you want to go into each and modify.

// Prisma is an ORM just like Sequelize and Mongoose, wich is used to facilitator of comunication with a database in SQL.

// Now install prisma using npm i -D prisma

// Now give the prisma an init using npx prisma init and add the .env to the .gitignore file

// in the schema.prisma you can change the provider depending on what database program you are using: postgres, mongoose, mongoDB, sequelize, etc. In this case we are using the postgres.

// Change the .env to fit the username, password and database you created in postgres. : DATABASE_URL="postgresql://username:password@localhost:5432/database"

// Create the DB model in the schema.prisma, Example:
model Table{
  id String @id @default(uuid()) // this is creating a column called id that accepts only strings and its a primary column that by default only accepts uniqueid.

  number Int @unique // this is creating a column called number that accepts integer values and it's only unique values

  createdAt DateTime @default(now()) // this is creating a column called createdAt that receives the date and by default receives the date now. Meaning the moment that it was created.

  updatedAt DateTime @updatedAt // this is creating a column called updatedAt that receives the date from @updatedAt
}

// Now run npx prisma db push to create the db schema in the database, this creates a new database or substitutes existing one, if you wish to just alter or add new thins use the migrate function

// After the database is created, run the npx prisma studio to check the client with the database and you can manually update, create and delete data. You can preferably use the beekeeper for this since the prisma studio is more limited(can't run queries), but usually for manual runs and checkings the studio should suffice.

// It's a good ideia now to divide three terminals, one for use in single actions, one for nest to run the start dev and one to run the prisma studio.

// In the terminal run npx prisma generate to check if the prisma was created correctly without errors

// Now run the npx nest generate module prisma, this will update the app.module by updating it's import and it will create the prisma folder in src and create the prisma.module.ts

// Now you can run the npx nest generate service prisma, this will add the service and service.spec in the prisma folder. if you run the npx nest generate service prisma --no-spec it will create only the service without the spec witch is used only for tests, so it's quite alright to be without.

// All prisma.service and prima.module is the same as it is only in charge of connecting the schema from the database to the src in the program.
prisma.service:
import { INestApplication, Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }

  async enableShutdownHooks(app: INestApplication) {
    this.$on('beforeExit', async () => {
      await app.close();
    });
  }
}

prisma.module:
import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}


// in the table.module, add the imports:[PrismaModule]

// in the table.service, add the constructor(private readonly prisma: PrismaService) {} right after the opening of the class, now update the this reference in the service